[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Anwendungsbaustein Auswertung von fds-Daten",
    "section": "",
    "text": "Preamble",
    "crumbs": [
      "Preamble"
    ]
  },
  {
    "objectID": "index.html#voraussetzungen",
    "href": "index.html#voraussetzungen",
    "title": "Anwendungsbaustein Auswertung von fds-Daten",
    "section": "Voraussetzungen",
    "text": "Voraussetzungen\n\nGrundlagen Python\nEinbinden von zusätzlichen Paketen\nArbeiten mit NumPy\nArbeiten mit Pandas\nPlotten mit Matplotlib\nGrundkentnisse im Simulieren von Bränden",
    "crumbs": [
      "Preamble"
    ]
  },
  {
    "objectID": "index.html#verwendete-pakete-und-datensätze",
    "href": "index.html#verwendete-pakete-und-datensätze",
    "title": "Anwendungsbaustein Auswertung von fds-Daten",
    "section": "Verwendete Pakete und Datensätze",
    "text": "Verwendete Pakete und Datensätze\n\nNumPy\npandas\nmatplotlib\nfdsreader",
    "crumbs": [
      "Preamble"
    ]
  },
  {
    "objectID": "index.html#bearbeitungszeit",
    "href": "index.html#bearbeitungszeit",
    "title": "Anwendungsbaustein Auswertung von fds-Daten",
    "section": "Bearbeitungszeit",
    "text": "Bearbeitungszeit\nGeschätzte Bearbeitungszeit: 4h",
    "crumbs": [
      "Preamble"
    ]
  },
  {
    "objectID": "index.html#lernziele",
    "href": "index.html#lernziele",
    "title": "Anwendungsbaustein Auswertung von fds-Daten",
    "section": "Lernziele",
    "text": "Lernziele\n\nEinlesen von fds Daten mit dem fdsreader\nAnalyse der Daten in Bezug auf ASET",
    "crumbs": [
      "Preamble"
    ]
  },
  {
    "objectID": "skript/introduction.html",
    "href": "skript/introduction.html",
    "title": "1  Einführung in ASET",
    "section": "",
    "text": "1.1 Datenerhebung\nDie Daten, die wir hier betrachten, wurden mithilfe des Fire Dynamics Simulator (FDS) erzeugt. Der FDS (Fire Dynamics Simulator) ist ein Modell der numerischen Strömungsmechanik, das zur Simulation von feuergetriebenen Strömungen verwendet wird. Es ermöglicht die Analyse und Vorhersage des Brandverhaltens sowie dessen Auswirkungen auf Gebäude und Umgebungen.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einführung in ASET</span>"
    ]
  },
  {
    "objectID": "skript/introduction.html#datenerhebung",
    "href": "skript/introduction.html#datenerhebung",
    "title": "1  Einführung in ASET",
    "section": "",
    "text": "Warnung\n\n\n\nDieses Lernmodul geht nicht weiter auf Simulationen oder den FDS ein. Die hier verwendeten Simulationsdaten werden als Download bereitgestellt.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einführung in ASET</span>"
    ]
  },
  {
    "objectID": "skript/aset.html",
    "href": "skript/aset.html",
    "title": "2  Verfügbare sichere Evakuierungszeit (ASET)",
    "section": "",
    "text": "2.1 Rauchsichtbarkeitsschicht\nIn diesem Beispiel wird die Höhe der Rauchsichtbarkeitsschicht analysiert. Die Unterscheidung erfolgt hier anhand eines einfachen Temperatur-Grenzwerts: Die lokale Schichthöhe ergibt sich aus dem niedrigsten Punkt, an dem eine bestimmte Temperatur überschritten wird. Die Auswertung erfolgt auf einem Slice entlang des Brenners (normal zur x-Achse).\n# Slice finden\nslc = sim.slices.get_by_id('BurnerTempX')\n\n# In globale Datenstruktur umwandeln und Koordinaten extrahieren\nslc_data, slc_coords = slc.to_global(masked=True, fill=np.nan, return_coordinates=True)\nZunächst erfolgt eine Visualisierung der Daten zu einem beliebigen Zeitpunkt. Weiße Bereiche stellen Hindernisse dar.\n# Zeitpunkt wählen\nit = slc.get_nearest_timestep(150)\n\n# Daten visualisieren\nplt.imshow(slc_data[it,:,:].T, origin='lower', vmax=200, extent=slc.extent.as_list())\nplt.title(f'Temperatur bei t={slc.times[it]:.2f}s')\nplt.xlabel('y-Position / m')\nplt.ylabel('z-Position / m')\nplt.colorbar(orientation='horizontal', label=f'{slc.quantity.name} / {slc.quantity.unit}')\n\n# plt.savefig('figs/appartment_temp_slice.svg', bbox_inches='tight')\n# plt.close()\nNun wird für jede y-Position der z-Index gesucht, an dem die Temperatur den Grenzwert überschreitet. Der niedrigste dieser Punkte ist die lokale Höhe der Rauchsichtbarkeitsschicht.\n# Grenzwert für Temperatur\ntemperatur_grenzwert = 75\n\n# Array zur Speicherung der lokalen Höhenwerte; Standard ist maximale z-Koordinate\nschicht_hoehe = np.full(slc_data.shape[1], slc_coords['z'][-1])\n\n# Schleife über y-Indizes\nfor ix in range(len(schicht_hoehe)):\n    # Indizes finden die den Grenzwert überschreiten\n    lt = np.where(slc_data[it, ix, :] &gt; temperatur_grenzwert)[0]\n    # Wenn welche existieren, wähle den niedrigsten von ihnen\n    if len(lt) &gt; 0:\n        schicht_hoehe[ix] = slc_coords['z'][lt[0]]\nDie resultierenden Werte können nun über dem Slice dargestellt werden, um die Plausibilität zu überprüfen.\n# Slice Daten\nplt.imshow(slc_data[it,:,:].T, origin='lower', vmax=200, extent=slc.extent.as_list())\nplt.title(f'Temperatur bei t={slc.times[it]:.2f}s')\nplt.xlabel('y-Position / m')\nplt.ylabel('z-Position / m')\nplt.colorbar(orientation='horizontal', label=f'{slc.quantity.name} / {slc.quantity.unit}')\n# Rauchsichtbarkeitsschichthöhe\nplt.plot(slc_coords['y'], schicht_hoehe, '.-', color='red')\n\n# plt.savefig('figs/appartment_temp_slice_height.svg', bbox_inches='tight')\n# plt.close()\nDie obige Methode kann auch über alle Zeitpunkte angewendet werden, um z. B. Mittelwert und Standardabweichung der Schichthöhe zu berechnen.\nmittelwert = np.zeros_like(slc.times)\nstandardabweichung = np.zeros_like(slc.times)\nres = np.zeros(slc_data.shape[1])\n\nfor it in range(len(slc.times)):\n    res[:] = slc_coords['z'][-1]\n    for ix in range(len(res)):\n        lt = np.where(slc_data[it, ix, :] &gt; temperatur_grenzwert)[0]\n        if len(lt) &gt; 0:\n            res[ix] = slc_coords['z'][lt[0]]\n    mittelwert[it] = np.mean(res)\n    standardabweichung[it] = np.std(res)\n# Darstellung des Mittelwerts und der Standartabweichung als Funktion der Zeit\nplt.plot(slc.times, mittelwert, label='Mittlere Schichthöhe')\nplt.plot(slc.times, standardabweichung, label='Standardabweichung')\nplt.grid()\nplt.legend()\nplt.xlabel('Zeit / s')\nplt.ylabel('Höhe / m')\n\n# Ergebnisse in Datei abspeichern\n# plt.savefig('figs/appartment_layer_mean_stddev.svg', bbox_inches='tight')\n# plt.close()\n\nText(0, 0.5, 'Höhe / m')\nBeide Werte können kombiniert visualisiert werden. Die Standardabweichung ergibt ein Band um den Mittelwert.\n# Mittelwert darstellen\nplt.plot(slc.times, mittelwert, label='Mittlere Schichthöhe')\n\n# Band um den Mittelwert darstellen mit Hilfe der Standartabweichung\nplt.fill_between(slc.times, mittelwert-standardabweichung, mittelwert+standardabweichung, color='C0', alpha=0.3)\n\n# Boden als Referenz zeigen\nplt.ylim(bottom=0)\nplt.grid()\nplt.legend()\nplt.xlabel('Zeit / s')\nplt.ylabel('Höhe / m')\n\n# plt.savefig('figs/appartment_layer_mean_band.svg', bbox_inches='tight')\n# plt.close()\n\nText(0, 0.5, 'Höhe / m')\nWenn bestimmte Bereiche ausgeschlossen werden sollen, kann eine koordinatenabhängige Maske verwendet werden.\n# Finde Indizes bei denen die y-Koordinate zwischen den angegebenen Werten liegt\nymin = 1\nymax = 4\nkoordinaten_maske = np.where((slc_coords['y'] &gt; ymin) & (slc_coords['y'] &lt; ymax))\n# Slice Daten\nplt.imshow(slc_data[it,:,:].T, origin='lower', vmax=200, extent=slc.extent.as_list())\nplt.title(f'Temperatur bei t={slc.times[it]:.2f}s')\nplt.xlabel('y-Position / m')\nplt.ylabel('z-Position / m')\nplt.colorbar(orientation='horizontal', label=f'{slc.quantity.name} / {slc.quantity.unit}')\n# Rauchsichtbarkeitsschichthöhe\nplt.plot(slc_coords['y'][koordinaten_maske], schicht_hoehe[koordinaten_maske], '.-', color='red')\n\n# plt.savefig('figs/appartment_temp_slice_height_mask.svg', bbox_inches='tight')\n# plt.close()\nDas gleiche Verfahren kann erneut verwendet werden, wobei Mittelwert und Standardabweichung nur auf die maskierten Werte berechnet werden.\nfor it in range(len(slc.times)):\n    res[:] = slc_coords['z'][-1]\n    for ix in np.ndindex(res.shape):\n        lt = np.where(slc_data[it, ix, :] &gt; temperatur_grenzwert)[1]\n        if len(lt) &gt; 0:\n            res[ix] = slc_coords['z'][lt[0]]\n    # Berechnungen werden nun mit den Werten aus der Maske durchgeführt\n    mittelwert[it] = np.mean(res[koordinaten_maske])\n    standardabweichung[it] = np.std(res[koordinaten_maske])\n# Selbe Darstellung wie zuvor\nplt.plot(slc.times, mittelwert, label='Mittlere Schichthöhe')\nplt.fill_between(slc.times, mittelwert-standardabweichung, mittelwert+standardabweichung, color='C0', alpha=0.3)\nplt.ylim(bottom=0)\nplt.grid()\nplt.legend()\nplt.xlabel('Zeit / s')\nplt.ylabel('Höhe / m')\n\n# plt.savefig('figs/appartment_layer_mean_band_mask.svg', bbox_inches='tight')\n# plt.close()\n\nText(0, 0.5, 'Höhe / m')",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Verfügbare sichere Evakuierungszeit (ASET)</span>"
    ]
  },
  {
    "objectID": "skript/fdsreader.html",
    "href": "skript/fdsreader.html",
    "title": "3  Fdsreader",
    "section": "",
    "text": "3.1 Installation und Import des Pakets\nDas fdsreader-Modul kann über pip installiert werden (siehe auch das GitHub-Repository):\nZur Einführung in die grundlegende Verwendung von fdsreader betrachten wir ein einfaches FDS-Szenario. Zunächst importieren wir das Modul:\nimport fdsreader\nDa wir die Daten auch visualisieren möchten, importieren wir zusätzlich matplotlib:\nimport matplotlib.pyplot as plt",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Fdsreader</span>"
    ]
  },
  {
    "objectID": "skript/fdsreader.html#installation-und-import-des-pakets",
    "href": "skript/fdsreader.html#installation-und-import-des-pakets",
    "title": "3  Fdsreader",
    "section": "",
    "text": "pip install fdsreader",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Fdsreader</span>"
    ]
  },
  {
    "objectID": "skript/fdsreader.html#auswahl-des-richtigen-ordners",
    "href": "skript/fdsreader.html#auswahl-des-richtigen-ordners",
    "title": "3  Fdsreader",
    "section": "3.2 Auswahl des richtigen Ordners",
    "text": "3.2 Auswahl des richtigen Ordners\nAls Nächstes muss der Reader auf das Verzeichnis zeigen, das die Simulationsdaten enthält, insbesondere die Smokeview-Datei:\n\n# Pfad zu den Daten definieren\npath_to_data = '../skript/01-data/first_example'\n\nsim = fdsreader.Simulation(path_to_data)\n\n/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/numpy/lib/_npyio_impl.py:1048: UserWarning: no explicit representation of timezones available for np.datetime64\n  arr = _load_from_filelike(\n\n\nDas Simulation-Objekt sim enthält nun alle Informationen und Daten des Simulationsausgangs:\n\nsim\n\nSimulation(chid=StecklerExample,\n           meshes=1,\n           obstructions=7,\n           slices=5,\n           data_3d=5,\n           smoke_3d=3,\n           devices=4)\n\n\nDie Variable sim enthält Informationen über das Gitter (MESH), vier Schnittdaten (SLCF) und vier Punktmessungen (DEVC). Das zusätzliche Messgerät – in der FDS-Eingabedatei wurden nur drei definiert – ist die Zeitspalte.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Fdsreader</span>"
    ]
  },
  {
    "objectID": "skript/fdsreader.html#messgeräte-daten",
    "href": "skript/fdsreader.html#messgeräte-daten",
    "title": "3  Fdsreader",
    "section": "3.3 Messgeräte-Daten",
    "text": "3.3 Messgeräte-Daten\n\n\n\n\n\n\nMessgeräte in FDS\n\n\n\nMessgeräte fungieren als virtuelle Sensoren, mit denen Daten wie Temperatur, Wärmestrom, Gaskonzentration, Geschwindigkeit usw. an bestimmten Punkten im Simulationsbereich aufgezeichnet werden können. Diese Daten sind entscheidend für das Verständnis des Verhaltens von Feuer und Rauch unter verschiedenen Bedingungen.\nEin Messgerät kann mit einem Label (ID) versehen werden, was die Identifizierung in der durch FDS erzeugten CSV-Datei vereinfacht. Es benötigt eine Position und eine zu messende Größe.\nPositionen können auf verschiedene Arten angegeben werden. Wir fokussieren uns hier auf einen Punkt über XYZ. Linien, Flächen und Volumen sind jedoch ebenso möglich.\nDer Parameter QUANTITY erwartet eine Zeichenkette, die angibt, welche Größe aufgezeichnet werden soll, z. B. TEMPERATURE für die Gastemperatur.\n\n\nDie einfachste Datenstruktur ist die Ausgabe der DEVC-Direktiven. Die verfügbaren Daten und Metainformationen können direkt ausgegeben werden:\n\n# Kurzreferenz für Bequemlichkeit – `devc` enthält alle Messgeräte\ndevc = sim.devices\nprint(devc)\n\n[Device(id='Time', xyz=(0.0, 0.0, 0.0), quantity=Quantity('TIME')),\nDevice(id='Temp_Door_Low', xyz=(1.45, 0.05, 0.1), quantity=Quantity('TEMPERATURE')),\nDevice(id='Temp_Door_Mid', xyz=(1.45, 0.05, 1.0), quantity=Quantity('TEMPERATURE')),\nDevice(id='Temp_Door_High', xyz=(1.45, 0.05, 1.65), quantity=Quantity('TEMPERATURE'))]\n\n\nDie Device-Klasse enthält alle relevanten Informationen (siehe Geräte-Dokumentation):\n\nfor i in devc:\n    print(f\"ID: {i.id},\\t Messgröße: {i.quantity_name}, \\t Position: {i.position}\")\n\nID: Time,    Messgröße: TIME,    Position: (0.0, 0.0, 0.0)\nID: Temp_Door_Low,   Messgröße: TEMPERATURE,     Position: (1.45, 0.05, 0.1)\nID: Temp_Door_Mid,   Messgröße: TEMPERATURE,     Position: (1.45, 0.05, 1.0)\nID: Temp_Door_High,  Messgröße: TEMPERATURE,     Position: (1.45, 0.05, 1.65)\n\n\nEinzelne Messgeräte, einschließlich der Zeitspalte, sind über Dictionary-Einträge mit ihrer ID als Schlüssel zugänglich. Die Daten eines einzelnen Messgeräts (Device.data) sind als NumPy-Array gespeichert:\n\ntype(devc['Temp_Door_Mid'].data)\n\nnumpy.ndarray\n\n\nDie Länge entspricht dem erwarteten Wert, also 1801, da die Simulation 1800 s dauerte und die Messgeräte jede Sekunde beschrieben wurden, einschließlich t = 0 s.\n\nlen(devc['Time'].data)\n\n1801\n\n\nEin erster Blick auf die Rohdaten (Device.data):\n\ndevc['Temp_Door_Mid'].data\n\narray([ 20.      ,  20.002083,  20.034418, ..., 105.32822 , 114.82179 ,\n       115.01705 ], shape=(1801,), dtype=float32)\n\n\nDie Messgerät-Daten können auch mit Matplotlib visualisiert werden:\n\n# Plot erstellen\nplt.plot(devc['Time'].data, devc['Temp_Door_High'].data)\n\n# Achsen beschriften\nplt.xlabel(\"Zeit / s\")\ndevc_id = devc['Temp_Door_High'].id\ndevc_q = devc['Temp_Door_High'].quantity_name\ndevc_u = devc['Temp_Door_High'].unit\nplt.ylabel(f\"{devc_q} ({devc_id}) / {devc_u}\")\n\n# Raster hinzufügen\nplt.grid()\n\n\n\n\n\n\n\n\nIn gleicher Weise können mehrere Messgeräte gleichzeitig geplottet werden, z. B. alle, deren Namen mit Temp_ beginnen:\n\n# Alle Messgeräte durchlaufen\nfor i in devc:\n    \n    # Nur Messgeräte mit ID, die mit 'Temp_' beginnt\n    if not i.id.startswith('Temp_'): \n        continue\n    \n    plt.plot(devc[\"Time\"].data, i.data, label=i.id)\n    \nplt.legend()\nplt.xlabel(\"Zeit / s\")\nplt.ylabel('Temperatur / $^\\circ$C')\nplt.grid()\n\n&lt;&gt;:12: SyntaxWarning: invalid escape sequence '\\c'\n&lt;&gt;:12: SyntaxWarning: invalid escape sequence '\\c'\n/tmp/ipykernel_3347/1963712746.py:12: SyntaxWarning: invalid escape sequence '\\c'\n  plt.ylabel('Temperatur / $^\\circ$C')",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Fdsreader</span>"
    ]
  },
  {
    "objectID": "skript/fdsreader.html#hrr-daten",
    "href": "skript/fdsreader.html#hrr-daten",
    "title": "3  Fdsreader",
    "section": "3.4 HRR-Daten",
    "text": "3.4 HRR-Daten\n\n\n\n\n\n\nHeat Release Rate (HRR)\n\n\n\nEin zentraler Parameter in der Brandmodellierung. Er beschreibt die Freisetzungsrate thermischer Energie und wird in Kilowatt (kW) oder Megawatt (MW) angegeben.\n\n\nWie bei den DEVC-Daten kann auch auf die im HRR-File gespeicherten Daten direkt zugegriffen werden. Diese befinden sich im Attribut hrr des Simulation-Objekts und nicht bei den Messgeräten:\n\nplt.plot(sim.hrr['Time'], sim.hrr['HRR'], label='Freisetzung durch Brand')\n\nplt.plot(sim.hrr['Time'], sim.hrr['Q_RADI'], label='Strahlung')\nplt.plot(sim.hrr['Time'], sim.hrr['Q_COND'], label='Leitung')\nplt.plot(sim.hrr['Time'], sim.hrr['Q_CONV'], label='Konvektion')\n\nplt.plot(sim.hrr['Time'], \n         sim.hrr['HRR'] + sim.hrr['Q_RADI'] + sim.hrr['Q_COND'] + sim.hrr['Q_CONV'], \n         color='grey', label='Summe', zorder=0)\n\nplt.xlabel('Zeit / s')\nplt.ylabel('Wärmefreisetzung / kW')\nplt.legend()\nplt.grid()",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Fdsreader</span>"
    ]
  },
  {
    "objectID": "skript/fdsreader.html#slice-daten",
    "href": "skript/fdsreader.html#slice-daten",
    "title": "3  Fdsreader",
    "section": "3.5 Slice-Daten",
    "text": "3.5 Slice-Daten\n\n\n\n\n\n\nSlices\n\n\n\nSlices sind eine Art der Ausgabe, bei der bestimmte physikalische Größen (z. B. Temperatur, Geschwindigkeit, Rauchkonzentration) innerhalb einer Ebene des Simulationsraums visualisiert werden können. Diese Schnitte geben einen Einblick, wie sich Größen über einen Bereich verteilen.\n\n\nDie durch SLCF erzeugten Daten erstrecken sich über zwei oder drei räumliche Dimensionen sowie über die Zeit. Zusätzlich können sie auf mehrere Meshes verteilt sein.\nDie Slice-Daten werden pro Mesh gespeichert. In diesem Beispiel gibt es nur ein Mesh, doch der Zugriff erfolgt trotzdem formell mit Index.\nDie Datenstruktur sieht wie folgt aus:\n\nsim.slices[sliceid][meshid].data[zeitindex, richtung1, richtung2]\n\nDabei ist sliceid der Index des Slices, meshid der Mesh-Index (hier: 0), und der Zugriff erfolgt über den Zeitindex sowie zwei Raumrichtungen (für 2D-Slices).\nEs gibt mehrere Slice-Objekte:\n\n# Verfügbare Slices ausgeben\nfor slice in sim.slices:\n    print(f\"Slicetyp [2D/3D]: {slice.type}\\n  Größe: {slice.quantity.name}\\n\", \n          f\" Ausdehnung: {slice.extent}\\n  Orientierung [1/2/3]: {slice.orientation}\\n\")\n\nSlicetyp [2D/3D]: 2D\n  Größe: TEMPERATURE\n  Ausdehnung: Extent([0.00, 0.00] x [-1.40, 1.40] x [0.00, 2.20])\n  Orientierung [1/2/3]: 1\n\nSlicetyp [2D/3D]: 2D\n  Größe: TEMPERATURE\n  Ausdehnung: Extent([-1.40, 2.60] x [0.00, 0.00] x [0.00, 2.20])\n  Orientierung [1/2/3]: 2\n\nSlicetyp [2D/3D]: 2D\n  Größe: W-VELOCITY\n  Ausdehnung: Extent([0.00, 0.00] x [-1.40, 1.40] x [0.00, 2.20])\n  Orientierung [1/2/3]: 1\n\nSlicetyp [2D/3D]: 2D\n  Größe: U-VELOCITY\n  Ausdehnung: Extent([-1.40, 2.60] x [0.00, 0.00] x [0.00, 2.20])\n  Orientierung [1/2/3]: 2\n\nSlicetyp [2D/3D]: 2D\n  Größe: W-VELOCITY\n  Ausdehnung: Extent([-1.40, 2.60] x [-1.40, 1.40] x [1.80, 1.80])\n  Orientierung [1/2/3]: 3\n\n\n\nEs gibt viele Wege einen bestimmten Slice unter den anderen zu finden. Eine Möglichkeit, den gewünschten Slice zu finden, ist das Filtern nach Quantity über filter_by_quantity:\n\n# Slice(s) mit W-Geschwindigkeit bekommen\nw_slice = sim.slices.filter_by_quantity(\"W-VELOCITY\")\nprint(w_slice)\n\nSliceCollection([Slice([2D] quantity=Quantity('W-VELOCITY'), cell_centered=False, extent=Extent([0.00, 0.00] x [-1.40, 1.40] x [0.00, 2.20]), extent_dirs=('y', 'z'), orientation=1),\nSlice([2D] quantity=Quantity('W-VELOCITY'), cell_centered=False, extent=Extent([-1.40, 2.60] x [-1.40, 1.40] x [1.80, 1.80]), extent_dirs=('x', 'y'), orientation=3)])\n\n\nOder die Auswahl über die Nähe zu einem Punkt:\n\n# Auswahl basierend auf der Nähe zu einem Punkt\nslc = w_slice.get_nearest(x=1, z=2)\nprint(slc)\n\nSlice([2D] quantity=Quantity('W-VELOCITY'), cell_centered=False, extent=Extent([-1.40, 2.60] x [-1.40, 1.40] x [1.80, 1.80]), extent_dirs=('x', 'y'), orientation=3)\n\n\nDer Zugriff auf Slice-Daten benötigt die Auswahl von einem bestimmten Mesh und Zeitindex. Die Funktion get_nearest_timestep hilft dabei:\n\n# Zeitindex nahe t=25 s auswählen\nit = slc.get_nearest_timestep(25)\nprint(f\"Zeitschritt: {it}\")\nprint(f\"Simulationszeit: {slc.times[it]}\")\n\nZeitschritt: 25\nSimulationszeit: 25.021108627319336\n\n\nDas folgende Beispiel zeigt eine Darstellung der Daten und die benötigten Schritte um diese anzupassen. Die Anpassungen finden anhand der Datenausrichtung aus der Function imshow statt.\n\n# Temperaturslice in y-Richtung auswählen\nslc = sim.slices.filter_by_quantity('TEMPERATURE').get_nearest(x=3, y=0)\nprint(slc)\n# Nur ein Mesh\nslc_data = slc[0].data\nprint(slc_data)\n\nSlice([2D] quantity=Quantity('TEMPERATURE'), cell_centered=False, extent=Extent([-1.40, 2.60] x [0.00, 0.00] x [0.00, 2.20]), extent_dirs=('x', 'z'), orientation=2)\n[[[ 20.        20.        20.       ...  20.        20.        20.      ]\n  [ 20.        20.        20.       ...  20.        20.        20.      ]\n  [ 20.        20.        20.       ...  20.        20.        20.      ]\n  ...\n  [ 20.        20.        20.       ...  20.        20.        20.      ]\n  [ 20.        20.        20.       ...  20.        20.        20.      ]\n  [ 20.        20.        20.       ...  20.        20.        20.      ]]\n\n [[ 20.030926  20.031328  20.032204 ...  20.001385  20.001268  20.00117 ]\n  [ 20.030703  20.031597  20.033634 ...  20.001493  20.001345  20.001238]\n  [ 20.031723  20.033785  20.038801 ...  20.001757  20.001535  20.001389]\n  ...\n  [ 20.006077  20.004908  20.002953 ...  20.001383  20.001154  20.00104 ]\n  [ 20.005085  20.004053  20.00236  ...  20.00129   20.001116  20.001026]\n  [ 20.004608  20.003656  20.0021   ...  20.00125   20.001104  20.001026]]\n\n [[ 20.12404   20.126698  20.133305 ...  20.026028  20.02525   20.025595]\n  [ 20.116137  20.11882   20.12633  ...  20.02626   20.025606  20.02608 ]\n  [ 20.114033  20.117645  20.128752 ...  20.02802   20.027351  20.027908]\n  ...\n  [ 20.018784  20.016739  20.013128 ...  20.00563   20.004776  20.004353]\n  [ 20.015898  20.014067  20.010876 ...  20.005054  20.004427  20.004118]\n  [ 20.01441   20.012737  20.00983  ...  20.004791  20.004278  20.00403 ]]\n\n ...\n\n [[ 44.00391   43.917053  43.920734 ... 143.89009  142.69537  142.16621 ]\n  [ 44.004223  43.863914  43.708996 ... 143.29715  142.09953  141.6622  ]\n  [ 43.81018   43.64982   43.4085   ... 142.64955  141.90448  141.75969 ]\n  ...\n  [ 20.284891  20.19156   20.076902 ...  90.631195  78.81051   72.00585 ]\n  [ 20.218634  20.140545  20.047134 ...  56.04536   43.176456  39.645744]\n  [ 20.151264  20.09307   20.028439 ...  34.67456   27.534237  27.970665]]\n\n [[ 45.228874  45.115242  44.938766 ... 150.18481  150.12732  149.83371 ]\n  [ 44.492287  44.350613  44.180614 ... 149.79759  150.0778   149.77635 ]\n  [ 43.646873  43.590538  43.562504 ... 147.7298   148.82109  149.29768 ]\n  ...\n  [ 20.281096  20.186028  20.071451 ... 106.69953   93.09295   83.79199 ]\n  [ 20.205025  20.13359   20.046276 ...  80.62758   71.11945   62.30358 ]\n  [ 20.16152   20.102564  20.033293 ...  65.56552   56.724525  46.839134]]\n\n [[ 42.762764  42.892406  42.67096  ... 146.0912   145.20709  144.58104 ]\n  [ 43.14627   43.263447  43.141045 ... 145.02187  144.6713   143.69063 ]\n  [ 43.753468  43.769325  43.798447 ... 141.0417   142.32797  141.77148 ]\n  ...\n  [ 20.268656  20.194078  20.08938  ...  72.89162   70.64532   65.348694]\n  [ 20.206676  20.136755  20.052374 ...  59.554634  49.809177  42.573883]\n  [ 20.180956  20.111738  20.035168 ...  48.16472   36.145966  31.134487]]]\n\n\n\n# Erste Visualisierung bei t=50 s\nit = slc.get_nearest_timestep(50)\nplt.imshow(slc_data[it])\n\n\n\n\n\n\n\n\n\n# Auf transponierte Darstellung mithilfe von ndarray.T zugreifen und anpassung des Ursprungs\nplt.imshow(slc_data[it].T, origin='lower')\n\n\n\n\n\n\n\n\n\n# Erste Visualisierung bei t=50 s\n# Angabe der Ausdehnung um von Indexen in den physikalischen Raum zu wechseln\n# Festsetzen eines Maximalwerts mit Hilfe von vmax\n\nplt.imshow(slc_data[it].T, \n           origin='lower',\n           vmax=200,\n           extent=slc.extent.as_list())\nplt.colorbar(label='Temperatur / °C', orientation='horizontal')\nplt.xlabel('x-Koordinate / m')\nplt.ylabel('z-Koordinate / m')\n\nText(0, 0.5, 'z-Koordinate / m')\n\n\n\n\n\n\n\n\n\n\n# Beispiel für Mehrfach-Plot\nlist_t = [0, 50, 100, 200, 300, 400]\nfig, axs = plt.subplots(2,3, sharex=True, sharey=True)\nfor i in range(len(list_t)):\n    it = slc.get_nearest_timestep(list_t[i])\n    axs.flat[i].imshow(slc_data[it].T,\n                       vmin=20,\n                       vmax=400,\n                       origin='lower', \n                       extent=slc.extent.as_list())\n    axs.flat[i].set_title(f\"t={slc.times[it]:.1f}\")",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Fdsreader</span>"
    ]
  }
]